#!/usr/bin/env ruby

#############################################################################
## Tests message encoding/decoding with MIO.
##
## Run from top-level directory: $ ruby -I . test/test_mio
##
## --------------------------------------------------------------------------
## Copyright (C) 2009 The Regents of the University of California.
## 
## This file is part of Marinda.
## 
## Marinda is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
## 
## Marinda is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
## 
## You should have received a copy of the GNU General Public License
## along with Marinda.  If not, see <http://www.gnu.org/licenses/>.
#############################################################################

require 'ostruct'
require 'optparse'

require 'test/unit'
require 'ext/mioext'

$options = OpenStruct.new
opts = OptionParser.new

opts.on("--[no-]verbose", TrueClass, "enable verbosity") do |v|
  $options.verbose = v
end

begin
  ARGV.replace opts.parse(*ARGV)
rescue OptionParser::ParseError
  $stderr.puts "ERROR: " + $!.to_s
  $stderr.puts opts
  exit 1
end


#============================================================================

class TestMIO < Test::Unit::TestCase

  B64_DECODE_TBL = {}  # character code => numeric value; e.g., 'A' => 0

  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".
    unpack("C*").each_with_index do |c, i|
    B64_DECODE_TBL[c] = i
  end


  def check_b64_encoding(s, expected)
    assert_not_nil(s, "b64 encoded string must not be nil")
    if s == "--"
      assert_equal(-9223372036854775808, n)
    else
      assert_match(/^(-)?[A-Za-z0-9\+\/]+$/, s)
      sign = (s[0, 1] == "-" ? -1 : 1)

      n = 0
      s.unpack("C*").each do |c|
        next if c == 45  # '-'
        n <<= 6
        n |= B64_DECODE_TBL[c]
        puts ">> " + n.to_s if $options.verbose
      end

      n = -n if sign < 0
      assert_equal(expected, n)
    end
  end


  # ------------------------------------------------------------------------

  def setup
    @m = Marinda::MIO.new unless @m
  end


  #=========================================================================
  ## ENCODING
  #=========================================================================

  def test_encode_arguments
    assert_raises(ArgumentError) { @m.encode nil }
    assert_raises(TypeError) { @m.encode 5 }
    assert_raises(TypeError) { @m.encode self }
  end


  def test_encode_validator
    check_b64_encoding("B", 1)
    check_b64_encoding("a", 26)
    check_b64_encoding("1", 53)

    check_b64_encoding("EA", 2**8)
    check_b64_encoding("QAA", 2**16)
    check_b64_encoding("BAAAA", 2**24)
    check_b64_encoding("-EA", -2**8)
    check_b64_encoding("-QAA", -2**16)
    check_b64_encoding("-BAAAA", -2**24)
    check_b64_encoding("/////", 2**30-1)  # max
    check_b64_encoding("-BAAAAA", -2**30)  # min

    # 64-bit fixnum or bignum
    check_b64_encoding("EAAAAA", 2**32)
    check_b64_encoding("-EAAAAA", -2**32)
    check_b64_encoding("D//////////", 2**62 - 1)
    check_b64_encoding("-EAAAAAAAAAA", -2**62)

    # bignum
    check_b64_encoding("EAAAAAAAAAA", 2**62)
    check_b64_encoding("H//////////", 2**63 - 1)  # max
  end


  def test_encode_basic_values
    assert_equal("`E", @m.encode([]))
    assert_equal("_", @m.encode([nil]))
    assert_equal("B", @m.encode([1]))
    assert_equal("$$", @m.encode([""]))
    assert_equal("$Zm9v", @m.encode(["foo"]))
    assert_equal("`T", @m.encode([true]))
    assert_equal("`F", @m.encode([false]))

    # 32-bit fixnum
    assert_equal("EA", @m.encode([2**8]))
    assert_equal("QAA", @m.encode([2**16]))
    assert_equal("BAAAA", @m.encode([2**24]))
    assert_equal("-EA", @m.encode([-2**8]))
    assert_equal("-QAA", @m.encode([-2**16]))
    assert_equal("-BAAAA", @m.encode([-2**24]))
    assert_equal("/////", @m.encode([2**30-1]))  # max
    assert_equal("-BAAAAA", @m.encode([-2**30]))  # min

    # 64-bit fixnum or bignum
    assert_equal("EAAAAA", @m.encode([2**32]))
    assert_equal("-EAAAAA", @m.encode([-2**32]))
    assert_equal("D//////////", @m.encode([2**62 - 1]))
    assert_equal("-EAAAAAAAAAA", @m.encode([-2**62]))

    # bignum
    assert_equal("EAAAAAAAAAA", @m.encode([2**62]))
    assert_equal("H//////////", @m.encode([2**63 - 1]))  # max
    assert_equal("--", @m.encode([-2**63]))  # min

    # floats (checking byte ordering as well as encoding)
    # ".QWeMKdzW6dw=".unpack("m").first.unpack("G")
    assert_equal(".P/AAAAAAAAA", @m.encode([1.0]))
    assert_equal(".P/AAAAAAAAE", @m.encode([1.0000000000000002]))
    assert_equal(".QWeMKdzW6dw", @m.encode([12345678.90123456]))

    puts if $options.verbose
    100.times do
      x = rand()  # [0.0, 1.0)
      s = [[x].pack("G")].pack("m").gsub!(/\=\n/, "")
      printf "%f => %s\n", x, s if $options.verbose
      assert_equal("." + s, @m.encode([x]))
    end
  end


  def test_random_b64_encoding
    # rand(2**32) - 2**31 => (2**32 - 1) - 2**31   (max)
    #                     => (2**31)(2 - 1) - 1    (max)

    1000.times do
      n = rand(2**32) - 2**31  # => [-2**31, 2**31-1]
      s = @m.encode [n]
      printf "\n%d => %s\n", n, s if $options.verbose
      check_b64_encoding s, n
    end

    1000.times do
      n = rand(2**64) - 2**63  # => [-2**63, 2**63-1]
      s = @m.encode [n]
      printf "\n%d => %s\n", n, s if $options.verbose
      check_b64_encoding s, n
    end
  end


  def test_encode_flat_array
    assert_equal("B,C", @m.encode([1, 2]))
    assert_equal("B,C,D", @m.encode([1, 2, 3]))
    assert_equal("B,$Zm9v", @m.encode([1, "foo"]))
    assert_equal("B,$Zm9v,`T,$YmFy", @m.encode([1, "foo", true, "bar"]))
    assert_equal("$Zm9v,$YmFy,$$", @m.encode(["foo", "bar", ""]))
    assert_equal("$Zm9v,$YmFy,$$,$$", @m.encode(["foo", "bar", "", ""]))
    assert_equal("_,C,_,D,_,_", @m.encode([nil, 2, nil, 3, nil, nil]))
  end


  def test_encode_nested_array_level_1
    assert_equal("()", @m.encode([[]]))
    assert_equal("(_)", @m.encode([[nil]]))
    assert_equal("(q)", @m.encode([[42]]))
    assert_equal("(B,C,D)", @m.encode([[1, 2, 3]]))
    assert_equal("(B,$Zm9v,$YmFy)", @m.encode([[1, "foo", "bar"]]))

    assert_equal("(),()", @m.encode([[], []]))
    assert_equal("(),(),()", @m.encode([[], [], []]))

    assert_equal("(B),C,D", @m.encode([[1], 2, 3]))
    assert_equal("B,(C),D", @m.encode([1, [2], 3]))
    assert_equal("B,C,(D)", @m.encode([1, 2, [3]]))

    assert_equal("B,($Zm9v,$YmFy)", @m.encode([1, ["foo", "bar"]]))
    assert_equal("($Zm9v,$YmFy),$$", @m.encode([["foo", "bar"], ""]))
    assert_equal("($Zm9v,$YmFy),($$,$$)", @m.encode([["foo", "bar"], ["", ""]]))
    assert_equal("(_,C,_),(D),_,(_)", @m.encode([[nil, 2, nil], [3], nil, [nil]]))
  end


  def test_encode_nested_array_level_2
    assert_equal("(())", @m.encode([[[]]]))
    assert_equal("((_))", @m.encode([[[nil]]]))
    assert_equal("((q))", @m.encode([[[42]]]))
    assert_equal("((B,C,D))", @m.encode([[[1, 2, 3]]]))
    assert_equal("((B,$Zm9v,$YmFy))", @m.encode([[[1, "foo", "bar"]]]))

    assert_equal("((),())", @m.encode([[[], []]]))
    assert_equal("((),(),())", @m.encode([[[], [], []]]))

    assert_equal("((B),C,D)", @m.encode([[[1], 2, 3]]))
    assert_equal("(B,(C),D)", @m.encode([[1, [2], 3]]))
    assert_equal("(B,C,(D))", @m.encode([[1, 2, [3]]]))

    assert_equal("B,(($Zm9v),$YmFy)", @m.encode([1, [["foo"], "bar"]]))
    assert_equal("B,($Zm9v,($YmFy))", @m.encode([1, ["foo", ["bar"]]]))
    assert_equal("B,($Zm9v,(C,D,$YmFy))", @m.encode([1, ["foo", [2, 3, "bar"]]]))
    assert_equal("(($Zm9v,$YmFy),(C,D)),($$,$$)", @m.encode([[["foo", "bar"], [2, 3]], ["", ""]]))
  end


  def test_encode_nested_array_level_n
    assert_equal("((()))", @m.encode([[[[]]]]))
    assert_equal("(((())))", @m.encode([[[[[]]]]]))
    assert_equal("((((_))))", @m.encode([[[[[nil]]]]]))
    assert_equal("((((q))))", @m.encode([[[[[42]]]]]))
    assert_equal("((((B,C,D))))", @m.encode([[[[[1, 2, 3]]]]]))
    assert_equal("((((B,$Zm9v,$YmFy))))", @m.encode([[[[[1, "foo", "bar"]]]]]))

    assert_equal("(),(()),((())),(((())))", @m.encode([[], [[]], [[[]]], [[[[]]]]]))
    assert_equal("(((()))),((())),(()),()", @m.encode([[[[[]]]], [[[]]], [[]], []]))

    assert_equal("(B,C,D),((E)),(((F,G))),(((($Zm9v))))", @m.encode([[1, 2, 3], [[4]], [[[5, 6]]], [[[["foo"]]]]]))
  end


  def test_encode_limits
    max_str = "X" * Marinda::MIO::MAX_RAW_VALUE_SIZE

    size = 0
    big_tuple = []
    while size < Marinda::MIO::MAX_MESSAGE_SIZE
      big_tuple << max_str
      size += Marinda::MIO::MAX_RAW_VALUE_SIZE
    end

    level = 0
    deep_tuple = []
    while level < Marinda::MIO::MAX_NESTING
      deep_tuple = [ deep_tuple ]
      level += 1
    end

    assert_nothing_raised(RuntimeError) { @m.encode [max_str] }
    assert_raises(Marinda::MIO::EncodeLimitExceeded) {
      @m.encode [max_str + "!"] }
    assert_raises(Marinda::MIO::EncodeLimitExceeded) {
      @m.encode big_tuple }
    assert_nothing_raised(Marinda::MIO::EncodeLimitExceeded) {
      @m.encode deep_tuple }
    assert_raises(Marinda::MIO::EncodeLimitExceeded) {
      @m.encode [deep_tuple] }
  end


  #=========================================================================
  ## DECODING
  #=========================================================================

  def test_decode_basic_values
    assert_equal([], @m.decode("`E"))
    assert_equal([nil], @m.decode("_"))
    assert_equal([true], @m.decode("`T"))
    assert_equal([false], @m.decode("`F"))
    assert_equal([1], @m.decode("B"))
    assert_equal([""], @m.decode("$$"))
    assert_equal(["foo"], @m.decode("$Zm9v"))

    # 32-bit fixnum
    assert_equal([2**8], @m.decode("EA"))
    assert_equal([2**16], @m.decode("QAA"))
    assert_equal([2**24], @m.decode("BAAAA"))
    assert_equal([-2**8], @m.decode("-EA"))
    assert_equal([-2**16], @m.decode("-QAA"))
    assert_equal([-2**24], @m.decode("-BAAAA"))
    assert_equal([2**30-1], @m.decode("/////"))  # max
    assert_equal([-2**30], @m.decode("-BAAAAA"))  # min

    # 64-bit fixnum or bignum
    assert_equal([2**32], @m.decode("EAAAAA"))
    assert_equal([-2**32], @m.decode("-EAAAAA"))
    assert_equal([2**62 - 1], @m.decode("D//////////"))
    assert_equal([-2**62], @m.decode("-EAAAAAAAAAA"))

    # bignum
    assert_equal([2**62], @m.decode("EAAAAAAAAAA"))
    assert_equal([2**63 - 1], @m.decode("H//////////"))  # max
    assert_equal([-2**63], @m.decode("--"))  # min

    # floats (checking byte ordering as well as encoding)
    # ".QWeMKdzW6dw=".unpack("m").first.unpack("G")
    assert_equal([1.0], @m.decode(".P/AAAAAAAAA"))
    assert_equal([1.0000000000000002], @m.decode(".P/AAAAAAAAE"))
    assert_equal([12345678.90123456], @m.decode(".QWeMKdzW6dw"))

    puts if $options.verbose
    100.times do
      x = rand()  # [0.0, 1.0)
      s = [[x].pack("G")].pack("m").gsub!(/\=\n/, "")
      printf "%f => %s\n", x, s if $options.verbose
      assert_equal([x], @m.decode("." + s))
    end

    # XXX test random string decoding
  end

end
