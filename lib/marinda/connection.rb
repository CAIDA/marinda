#############################################################################
## TCP connections between the local and global servers.
##
## See Marinda::Client and Marinda::Channel for the classes that implement
## connections between clients and the local server.
##
## --------------------------------------------------------------------------
## Copyright (C) 2007, 2008, 2009 The Regents of the University of California.
## 
## This file is part of Marinda.
## 
## Marinda is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
## 
## Marinda is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
## 
## You should have received a copy of the GNU General Public License
## along with Marinda.  If not, see <http://www.gnu.org/licenses/>.
##
## $Id: connection.rb,v 1.24 2009/03/17 00:54:19 youngh Exp $
#############################################################################

require 'socket'
require 'openssl'

module Marinda

class InsecureClientConnection

  attr_accessor :host, :port

  def initialize(host, port)
    @host = host  # IP address or hostname
    @port = port
  end

  def open(must_succeed=true)
    begin
      TCPSocket.new @host, @port
    rescue
      $log.err "InsecureClientConnection#open failed: %p", $!
      if must_succeed
	sleep 60
	retry
      else
	raise
      end
    end
  end

end


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

class InsecureServerConnection

  attr_accessor :port, :sock

  def initialize(port)
    @port = port
    # See comments at ServerSSLConnection for the reason for 0.0.0.0.
    @sock = TCPServer.new '0.0.0.0', @port
  end

  def accept(must_succeed=true)
    begin
      @sock.accept
    rescue
      $log.err "InsecureServerConnection#accept failed: %p", $!
      if must_succeed
	sleep 60
	retry
      else
	raise
      end
    end
  end

  # Note: peeraddr() can raise Errno::EINVAL if the remote end closes
  #       the socket (see getpeername(2)).
  # Note: If peeraddr() is slow, then set BasicSocket.do_not_reverse_lookup
  #       to false.
  def accept_with_whitelist(nodes)
    begin
      client_sock = @sock.accept
      peer_ip = client_sock.peeraddr.last
      node_id = nodes[peer_ip]
      if node_id
        $log.info "InsecureServerConnection#accept_with_whitelist: " +
          "accepting connection from %s, node %d", peer_ip, node_id
        return client_sock, node_id
      else
        $log.notice "InsecureServerConnection#accept_with_whitelist: " +
          "rejecting connection from %s: unknown node", peer_ip
        client_sock.close rescue nil
        return nil
      end
    rescue
      $log.err "InsecureServerConnection#accept_with_whitelist failed: %p", $!
      return nil
    end
  end

end


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
class SSLConnection

  # NOTES:
  #
  #  * cert_file and key_file should be in PEM format, though others might
  #    be supported.
  #
  #  * If key_file is password protected, then you will be prompted for a
  #    password.  To remove the password protection, do
  #
  #       openssl rsa -in key.pem -out key.INSECURE.pem
  #       chmod 600 key.INSECURE.pem
  #
  #  * ca_file and ca_path should not both be defined; at least one should
  #    be defined.
  #
  #  * ca_file should be in PEM format, though others might be supported.
  #
  #  * ca_path should give the path to a directory containing individual
  #    CA certificate files with names that are generated by hashing the
  #    certificates in some special way, which the c_rehash script
  #    bundled with OpenSSL does for you.

  def initialize(cert_file, key_file, ca_file, ca_path)
    cert = OpenSSL::X509::Certificate.new File::read(cert_file)
    key = OpenSSL::PKey::RSA.new File::read(key_file)

    @context = OpenSSL::SSL::SSLContext.new
    @context.cert = cert
    @context.key = key
    @context.verify_mode =
      OpenSSL::SSL::VERIFY_PEER | OpenSSL::SSL::VERIFY_FAIL_IF_NO_PEER_CERT
    @context.ca_file = ca_file if ca_file
    @context.ca_path = ca_path if ca_path

    # NOTE: The inclusion of OP_NO_TLSv1 is a (non-ideal) workaround for
    #       some bug in OpenSSL.  This option should be removed when the
    #       bug is finally squashed.  In short, without this option,
    #       connections to and from localhost fail with
    #
    #  client: OpenSSL::SSL::SSLError: sslv3 alert bad record mac
    #  server: OpenSSL::SSL::SSLError: decryption failed or bad record mac
    #
    #       Remote connections still work without this option, however.
    #       The issue seems to be related to OP_TLS_ROLLBACK_BUG
    #       (see SSL_CTX_set_options(3)), but using this option doesn't help.
    #       See also http://marc.theaimsgroup.com/?l=openssl-dev&m=108444932120941&w=2
    @context.options = OpenSSL::SSL::OP_NO_SSLv2 | OpenSSL::SSL::OP_NO_TLSv1
  end

end

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
class ClientSSLConnection < SSLConnection

  attr_accessor :host, :port

  def initialize(host, port, cert_file, key_file, ca_file, ca_path)
    super(cert_file, key_file, ca_file, ca_path)
    @host = host
    @port = port
  end

  # NOTE: Some possible exceptions:
  #
  #             TCPSocket.new => SystemCallError
  #     post_connection_check => OpenSSL::SSL::SSLError "hostname not match"

  def open(must_succeed=true)
    s = ssl = nil
    begin
      s = TCPSocket.new @host, @port
      ssl = OpenSSL::SSL::SSLSocket.new s, @context
      ssl.sync_close = true
      ssl.connect
      $log.info "ClientSSLConnection#open: opened connection to %s",
        ssl.peeraddr[-2]
      ssl.post_connection_check s.peeraddr[-2]  # check server DNS name
      ssl
    rescue
      $log.err "ClientSSLConnection#open failed: %p", $!
      s.close rescue nil if s
      ssl.close rescue nil if ssl
      if must_succeed
	sleep 60
	retry
      else
	raise
      end
    end
  end

end


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
class ServerSSLConnection < SSLConnection

  attr_accessor :port, :sock

  def initialize(port, cert_file, key_file, ca_file, ca_path,
		 check_client_name)
    super(cert_file, key_file, ca_file, ca_path)
    @port = port
    @check_client_name = check_client_name

    # NOTE: The use of '0.0.0.0' is a workaround for a problem on FreeBSD.
    #       Without it, TCPServer creates an IPv6 listening socket even
    #       on machines without IPv6 connectivity.  Moreover, this IPv6
    #       socket only accepts IPv6 packets, unlike on some systems (e.g.,
    #       MacOS X) in which IPv6 sockets can (in certain situations)
    #       accept connections from both IPv4 and IPv6 clients.
    #
    #       TCPServer.new choosing an IPv6 socket rather than an IPv4
    #       socket on a system without IPv6 connectivity is an issue,
    #       perhaps, with Ruby.  However, the fact that IPv6 sockets don't
    #       support IPv4 clients on FreeBSD systems is an issue with
    #       FreeBSD.  Indeed, FreeBSD intentionally disallows this
    #       behavior by default, presumably in accordance with the
    #       recommendations of the Internet draft "IPv4-Mapped Addresses
    #       on the Wire Considered Harmful"
    #   (http://tools.ietf.org/html/draft-itojun-v6ops-v4mapped-harmful-02)
    #
    #       This feature is controlled by net.inet6.ip6.v6only, which is
    #       true by default (verified under FreeBSD 5.4 and 6.1).
    #       This feature can also be toggled with the IPV6CTL_V6ONLY
    #       socket option (at level IPPROTO_IPV6), but Ruby doesn't provide
    #       a symbolic constant for this option (so toggling it under
    #       Ruby is non-portable).
    #
    #       See IP6(4) and inet6(4) on FreeBSD systems for more details.
    @sock = TCPServer.new '0.0.0.0', @port
  end

  # NOTE: Some possible exceptions:
  #
  #            @sock.accept => SystemCallError
  #     post_connection_check => OpenSSL::SSL::SSLError "hostname not match"

  def accept(must_succeed=true)
    ssl = nil
    begin
      @ssl_sock = OpenSSL::SSL::SSLServer.new @sock, @context unless @ssl_sock
      ssl = @ssl_sock.accept
      $log.info "ServerSSLConnection#accept: accepted connection from %s",
        ssl.peeraddr[-1]
      if @check_client_name
	peer_ip = ssl.peeraddr[-1]
	ssl.post_connection_check peer_ip
      end
      ssl
    rescue
      $log.err "ServerSSLConnection#accept failed: %p", $!
      ssl.close rescue nil if ssl 
      if must_succeed
	sleep 60
	retry
      else
	raise
      end
    end
  end

  # This method is needed to prevent a trivial denial-of-service attack that
  # can be launched against OpenSSL::SSL::SSLServer#accept.  Because
  # SSLServer#accept blocks waiting for SSL data, a malicious user can
  # simply do 'telnet ark.caida.org 8742' to cause GlobalServer to hang
  # indefinitely, denying legitimate connections.
  #
  # Note: peeraddr() can raise Errno::EINVAL if the remote end closes
  #       the socket (see getpeername(2)).
  # Note: If peeraddr() is slow, then set BasicSocket.do_not_reverse_lookup
  #       to false.
  def accept_with_whitelist(nodes)
    begin
      client_sock = @sock.accept
      peer_ip = client_sock.peeraddr.last
      node_id = nodes[peer_ip]
      if node_id
        $log.info "ServerSSLConnection#accept_with_whitelist: " +
          "accepting connection from %s, node %d", peer_ip, node_id
      else
        $log.notice "ServerSSLConnection#accept_with_whitelist: " +
          "rejecting connection from %s: unknown node", peer_ip
        client_sock.close rescue nil
        return nil
      end
    rescue
      $log.err "ServerSSLConnection#accept_with_whitelist failed: %p", $!
      return nil
    end

    begin
      ssl = OpenSSL::SSL::SSLSocket.new client_sock, @context
      ssl.sync_close = true
      ssl.accept
      ssl.post_connection_check peer_ip if @check_client_name
      return ssl, node_id

    rescue OpenSSL::SSL::SSLError
      $log.err "ServerSSLConnection#accept_with_whitelist failed: %p", $!
      client_sock.close rescue nil
      return nil

    rescue
      $log.err "ServerSSLConnection#accept_with_whitelist: " +
        "SSL accept/validation failed: %p", $!
      client_sock.close rescue nil
      return nil
    end
  end

end

end  # module Marinda
