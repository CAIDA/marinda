#############################################################################
## A class for multiplexing I/O at the local tuple space onto the single
## connection between the local and global tuple spaces.
##
## GlobalSpaceDemux does the demultiplexing at the global tuple space.
##
## --------------------------------------------------------------------------
## Copyright (C) 2007, 2008, 2009 The Regents of the University of California.
## 
## This file is part of Marinda.
## 
## Marinda is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
## 
## Marinda is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
## 
## You should have received a copy of the GNU General Public License
## along with Marinda.  If not, see <http://www.gnu.org/licenses/>.
##
## $Id: globalmux.rb,v 1.53 2009/04/02 23:29:38 youngh Exp $
#############################################################################

require 'ostruct'
require 'thread'
require 'monitor'
require 'socket'
require 'yaml'

require 'marinda/list'
require 'marinda/msgcodes'
require 'marinda/tuple'

module Marinda

class GlobalSpaceMux

  private

  include MuxMessageCodes

  CVS_ID = "$Id: globalmux.rb,v 1.53 2009/04/02 23:29:38 youngh Exp $"
  HEARTBEAT_INTERVAL = 60  # idle seconds between heartbeat messages
  MESSAGE_LENGTH_SIZE = 4  # num bytes in length field of transmitted messages
  READ_SIZE = 4096         # num bytes to read at once with sysread

  class GlobalSpaceRequest
    attr_reader :worker, :result_method, :request_data

    def initialize(worker, result_method, request_data)
      @worker = worker
      @result_method = result_method
      @request_data = request_data
    end

    def inspect
      sprintf "\#<GlobalSpaceRequest:%#x @worker=%#x @result_method=%p, " +
        "@request_data=%#x>", object_id, @worker.object_id, @result_method,
        @request_data.object_id
    end
  end

  Message = Struct.new :seqnum, :command, :contents, :request
  ReadBuffer = Struct.new :length, :payload
  WriteBuffer = Struct.new :payload

  def initialize(node_id, connection)
    @node_id = node_id

    # This value is used by both the mux and demux to determine whether one
    # end has restarted with a loss of state.  Specifically, if the session
    # ID sent by the mux on reconnection doesn't match the session ID
    # recorded by the demux, then one end has lost state.  If the mux sends
    # a zero session ID, then the mux has either started for the first time
    # or restarted after a failure with loss of state.  If there was loss
    # of state, then the global server purges any global state associated
    # with the previous session.  This involves purging things like private
    # global regions which are never accessible beyond any given session.
    #
    # If the demux has restarted with a loss of state (that is, the mux
    # sends a non-zero session ID but the demux has no record of any active
    # session), then the only recourse is for the mux to shut down.  This
    # is a fairly drastic measure, but the only scenario where this can
    # happen is when the global tuple space suffers a catastrophic failure
    # (that can't be recovered from with checkpoints), and it's probably
    # pointless for the local tuple space to continue on after that.
    #
    # The session ID is always generated by the global server.  The mux
    # sends a zero session ID on initial start up in HELLO_CMD and
    # receives the actual session ID in HELLO_RESP.
    @session_id = 0

    @connection = connection
    @sock = nil        # open socket to demux or nil if lost connection
    @protocol = nil
    @remote_banner = nil

    # The next available sequence number (that is, use this value in a
    # message and then post increment the variable).
    #
    # This must be > 0, since a seqnum of 0 is used by GlobalSpaceMux and
    # GlobalSpaceDemux to mean that no messages have ever been received
    # from each other.
    #
    # NOTE: You must access this only under @inbox.synchronize because both
    #       the LocalSpace and GlobalSpaceMux threads can access this.
    @seqnum = 1

    # The highest sequence number ever observed in messages received from
    # GlobalSpaceDemux; specifically, this gives the seqnum of the latest
    # response issued by the demux that has been received by the mux; 0 is not
    # a valid seqnum and instead means no messages have ever been received.
    @demux_seqnum = 0

    # Messages whose receipt has yet to be acknowledged by the demux.
    # All messages requested to be sent are automatically enqueued into this
    # list, so not all messages on this list have been sent out yet.  The
    # messages should be in sorted order according to {message.seqnum}.
    @unacked_messages = List.new  # [Message]

    # Requests that have not yet gotten a response from the demux.  We're
    # talking about a response at the level of Region/GlobalSpace operations
    # and not merely low-level message acknowledgment, which may or may not
    # have happened (that is, being in @ongoing_requests implies nothing about
    # the status of message receipt).
    #
    # Currently, in order for messages to be removed from @ongoing_requests,
    # all commands issued by the mux must be responded to by the demux,
    # either with some command-specific result, like a tuple, or with the
    # generic ACK_RESP.
    @ongoing_requests = Hash.new  # seqnum => Message

    # This is for keeping track of the GlobalSpaceMux seqnum used to send a
    # request to GlobalSpaceDemux, so that the request can be cancelled
    # later with a CANCEL_CMD.  This seqnum is referred to as the 'reqnum'
    # in the global server.
    #
    # (RegionRequest || GlobalSpaceRequest).object_id => seqnum
    #
    # NOTE: You must access this only under @inbox.synchronize because both
    #       the LocalSpace and GlobalSpaceMux threads can access this.
    @request_seqnum = Hash.new  

    #.....................................................................

    # Hack: Also use @inbox for general thread synchronization needs
    #       between the LocalSpace and GlobalSpaceMux threads.
    @inbox = List.new
    @inbox.extend MonitorMixin

    @read_buffer = ReadBuffer.new
    @write_queue = List.new  # [WriterBuffer]

    sock_pair = UNIXSocket.pair Socket::SOCK_STREAM, 0
    @control_read = sock_pair[0]
    @control_write = sock_pair[1]
    @control_write.extend MonitorMixin

    @read_set = [ @control_read ]
    @write_set = []

    @dispatch = {}
    @dispatch[:write_message] = method :handle_write_message
    @dispatch[:connection_opened] = method :handle_connection_opened

    @thread = Thread.new(&method(:execute_toplevel))

    open_connection
  end


  def open_connection
    Thread.new do
      $log.info "GlobalSpaceMux: trying to connect to demux..."
      sleep 10   # prevent rapid connection attempts
      sock = @connection.open
      enqueue_event :connection_opened, sock
    end
  end


  def execute_toplevel
    begin
      execute()
    rescue
      msg = sprintf "GlobalSpaceMux: thread exiting on uncaught exception at " +
        "top-level: %p; backtrace: %s", $!, $!.backtrace.join(" <= ")
      $log.err "%s", msg
      log_failure msg rescue nil
      exit 1
    end
  end


  def log_failure(msg)
    path = (ENV['HOME'] || "/tmp") +
      "/marinda-globalmux-failed.#{Time.now.to_i}.#{$$}"
    File.open(path, "w") do |file|
      file.puts msg
    end
  end


  def execute
    loop do
      if $debug_mux_io_select
        $log.debug "GlobalSpaceMux: waiting for I/O ..."
        $log.debug "mux select read_set (%d fds): %p",
          @read_set.length, @read_set
        $log.debug "mux select write_set (%d fds): %p",
          @write_set.length,@write_set
      end

      # XXX select can throw "closed stream (IOError)" if a write file
      #     descriptor has been closed previously; we may want to catch
      #     this exception and remove the closed descriptor.  Strictly
      #     speaking, users shouldn't be passing in closed file descriptors.
      readable, writable = select @read_set, @write_set, nil, HEARTBEAT_INTERVAL
      if $debug_mux_io_select
        $log.debug "mux select returned %d readable, %d writable",
          (readable ? readable.length : 0), (writable ? writable.length : 0)
      end

      if readable
        readable.each do |sock|
          $log.debug "mux readable %p", sock if $debug_mux_io_select
          if sock.equal? @control_read
            handle_messages
          else
            read_data sock
          end
        end
      end

      if writable && @sock   # skip writing if lost connection
	writable.each do |sock|
          $log.debug "mux writable %p", sock if $debug_mux_io_select
	  write_data sock
	end
      end

      # Currently, checking readable != nil is enough, since all control
      # messages involve some (eventual) communication with the demux.
      unless readable || writable
        if @sock && @write_queue.empty?
          now = Time.now
          $log.info "sending heartbeat at %s (%d)", now.to_s, now.to_i
          @write_queue << WriteBuffer[generate_heartbeat_message]
          @write_set << @sock
          # don't add heartbeat to @unacked_messages or @ongoing_requests
        end
      end
    end
  end


  def handle_messages
    data = @control_read.sysread READ_SIZE

    messages = []
    @inbox.synchronize do
      data.length.times do
	messages << @inbox.shift
      end
    end

    messages.each do |message|
      $log.debug "mux handle message %s",
        inspect_message(message) if $debug_mux_commands
      handler = @dispatch[message[0]]
      if handler
	handler.call(*message)
      else
	$log.err "GlobalSpaceMux#handle_messages: ignoring " +
	  "unknown message type: %p", message
      end
    end
  end


  def handle_connection_opened(command, sock)
    @write_queue = List.new
    @write_queue << WriteBuffer[generate_hello_message]

    @unacked_messages.each do |message|
      @write_queue << WriteBuffer[marshal_message(message)]
    end

    @sock = sock
    @read_set << sock
    @write_set << sock
  end


  def handle_write_message(command, message)
    if $debug_mux_io_bytes
      $log.debug "handle_write_message: seqnum=%d, command=%d, contents=%p",
        message.seqnum, message.command, message.contents
    end

    if @sock
      @write_set << @sock if @write_queue.empty?
      @write_queue << WriteBuffer[marshal_message(message)]
    end
    @unacked_messages << message
    @ongoing_requests[message.seqnum] = message
  end


  def process_demux_message(payload)
    # mux_seqnum: the highest mux sequence number ever observed by
    #             GlobalSpaceDemux in commands it received from
    #             GlobalSpaceMux, up to the point at which the demux
    #             sent its latest response; a value of 0 means the demux
    #             had never received commands before
    #
    # demux_seqnum: the latest sequence number at the GlobalSpaceDemux-end
    #             of the link; this gives the seqnum of the latest response
    #             issued by the demux that was just received by the mux;
    #             valid seqnums are >= 1
    mux_seqnum, demux_seqnum, response_code, response_payload =
      payload.unpack("wwCa*")

    if $debug_mux_io_messages
      $log.debug "process_demux_message: mux_seqnum=%d, " +
        "demux_seqnum=%d, response=%p, payload=%p",
        mux_seqnum, demux_seqnum, response_code, response_payload
    end

    unless demux_seqnum == 0  # i.e., response_code == HELLO_RESP
      while !@unacked_messages.empty? &&
          @unacked_messages.first.seqnum <= mux_seqnum
        @unacked_messages.shift
      end

      if demux_seqnum > @demux_seqnum
	@demux_seqnum = demux_seqnum 
      else
        $log.info "discarding stale response (<= demux_seqnum %d): " +
          "mux_seqnum=%d, demux_seqnum=%d, response=%p, payload=%p",
          @demux_seqnum, mux_seqnum, demux_seqnum,
          response_code, response_payload
	return  # stale response: ignore it
      end
    end

    seqnum, *arguments = decode_response response_code, response_payload
    demux_response response_code, seqnum, arguments
  end


  def decode_response(code, payload)
    case code
    when ERROR_RESP
      return payload.unpack("wCa*") # command_seqnum, subcode, message

    when HELLO_RESP
      command_seqnum, protocol, rest = payload.unpack("wNa*")
      if protocol == 0
        $log.err "global server rejected connection negotiation with error " +
          "%p", rest
        exit 1
      elsif protocol == 1 || protocol > PROTOCOL_VERSION
        $log.err "global server is running the unsupported v%d protocol",
          protocol
        exit 1
      end

      hello_node_id, hello_session_id, banner = rest.unpack("nwa*")
      return [command_seqnum, protocol, hello_node_id, hello_session_id, banner]

    when ACK_RESP
      return payload.unpack("w")  # command_seqnum

    when PORT_RESP
      return payload.unpack("ww")  # command_seqnum, port

    when TUPLE_RESP
      command_seqnum, flags, sender, forwarder, seqnum, values_yaml =
	payload.unpack("wNwwwa*")

      values = YAML.load values_yaml
      tuple = Tuple.new sender, values
      tuple.flags = flags
      tuple.forwarder = (forwarder == 0 ? nil : forwarder)
      tuple.seqnum = seqnum
      return [command_seqnum, tuple]

    when TUPLE_NIL_RESP
      retval = payload.unpack("w")  # command_seqnum
      retval << nil
      return retval

    else
      # XXX -- fix this to fail or recover
      return [ ERROR_RESP, ERRORSUB_UNKNOWN_RESPONSE,
	"protocol error: unknown response code #{response_code} from GSDemux",
        payload ]
    end
  end


  # command_seqnum is the sequence number (on the GlobalSpaceMux end)
  # of the command (issued by GlobalSpaceMux) that elicited the response
  # being processed.
  def demux_response(response_code, command_seqnum, arguments)
    # Always purge ongoing_requests for non-stream operations.  Each
    # iteration operation must re-instate the request on each iteration.
    message = @ongoing_requests.delete command_seqnum
    if message && (message.command == MONITOR_STREAM_CMD ||
                   message.command == CONSUME_STREAM_CMD)
      @ongoing_requests[command_seqnum] = message
    end

    if $debug_mux_commands
      $log.debug "demux_response: code=%d (%s), seqnum=%d, args=%p, msg=%p",
        response_code, DEMUX_RESPONSES[response_code], command_seqnum,
        arguments, message
    end

    # Ignore outdated responses following command cancellation; for example,
    # a tuple response to a cancelled monitor.
    return unless message || response_code == HELLO_RESP

    unless response_code == HELLO_RESP
      # We don't delete the request seqnum mapping for stream operations
      # because stream operations remain in place in the global server
      # until explicitly cancelled.  All other operations (singleton and
      # iteration) must re-instate a request each time/iteration.
      unless message.command == MONITOR_STREAM_CMD ||
          message.command == CONSUME_STREAM_CMD
        # The cancellation message has a pointer to the same request object
        # as the message being cancelled, so the following removes the
        # request seqnum mapping for "both" messages at once.
        reqnum = nil
        @inbox.synchronize do
          reqnum = @request_seqnum.delete message.request.object_id
        end

        # {reqnum} can be nil if a client disconnects abruptly between
        # sending a command and receiving a response.
        if reqnum && message.command == CANCEL_CMD
          cancelled_message = @ongoing_requests.delete reqnum
          unless cancelled_message
            $log.notice "GlobalSpaceMux#demux_response: no Message found in " +
              "@ongoing_requests for cancelled operation with request " +
              "seqnum %d", reqnum
          end
        end
      end
    end

    case response_code
    when ERROR_RESP
      fail "UNIMPLEMENTED"  # XXX

    when HELLO_RESP
      @protocol, hello_node_id, hello_session_id, @remote_banner = arguments
      $log.info "got hello: protocol=%d, node_id=%d, session_id=%#x, " +
        "banner=%p", @protocol, hello_node_id, hello_session_id,
        @remote_banner

      if @node_id != hello_node_id
        $log.err "inconsistent node assignment: global server thinks we're " +
          "node %d, while local config says %d", hello_node_id, @node_id
        exit 1
      end

      if @session_id == 0
        $log.info "starting up with new session_id=%#x", hello_session_id
        @session_id = hello_session_id
      elsif @session_id == hello_session_id
        $log.info "continuing with previous session_id=%#x", @session_id
      else # @session_id != 0 && hello_session_id == 0
        $log.err "global server failed with a loss of state since last " +
          "connection (previous session_id=%#x); shutting down local server",
          @session_id
        exit 1
      end

    when ACK_RESP
      # nothing further to do

    when PORT_RESP, TUPLE_RESP, TUPLE_NIL_RESP
      request = message.request
      if request.instance_of? GlobalSpaceRequest
        request.worker.__send__ request.result_method, self,
          request.request_data, *arguments
      else # request.instance_of? RegionRequest
        # Ensure unacknowledged messages don't accumulate in the global server.
        enq_ack() if request.operation == :monitor_stream ||
                     request.operation == :consume_stream
        request.worker.mux_result request.port, request, *arguments
      end

    else
      fail "unexpected peer response code '#{response_code}'"
    end
  end


  #--------------------------------------------------------------------------

  def generate_hello_message
    contents = [HELLO_CMD, PROTOCOL_VERSION, @node_id, @session_id, CVS_ID].
      pack("CNnwa*")
    marshal_contents 0, contents
  end


  def generate_heartbeat_message
    contents = [ HEARTBEAT_CMD, Time.now.to_i ].pack("CN")
    marshal_contents 0, contents
  end


  def marshal_message(message)
    marshal_contents message.seqnum, message.contents
  end


  def marshal_contents(mux_seqnum, contents)
    header = [ mux_seqnum, @demux_seqnum ].pack("ww")
    length = header.length + contents.length
    [ length ].pack("N") + header + contents
  end


  #--------------------------------------------------------------------------

  def enq_write(recipient, tuple)
    command = WRITE_CMD
    flags = tuple.flags
    sender = tuple.sender
    forwarder = (tuple.forwarder || 0)
    values = YAML.dump tuple.values
    contents = [ command, flags, recipient, sender, forwarder, values ].
      pack("CNwwwa*")
    enq_message command, contents
  end


  def enq_command(command, recipient, request, cursor=nil)
    sender = request.template.sender
    values = YAML.dump request.template.values
    if cursor
      contents = [ command, recipient, sender, cursor, values].pack("Cwwwa*")
    else
      contents = [ command, recipient, sender, values ].pack("Cwwa*")
    end
    enq_message command, contents, request
  end


  def enq_cancel(recipient, request)
    command = CANCEL_CMD
    mux_seqnum = nil
    @inbox.synchronize do
      mux_seqnum = @request_seqnum[request.object_id]
    end
    if mux_seqnum
      contents = [ command, recipient, mux_seqnum ].pack("Cww")
      enq_message command, contents, request
    else
      $log.notice "GlobalSpaceMux#enq_cancel: no mux_seqnum found for " +
        "request %p", request
    end
  end


  def enq_ack
    command = ACK_CMD
    contents = [ command ].pack("C")
    enq_message command, contents
  end


  def enq_create_private_region_command(sender, request_data)
    command = CREATE_PRIVATE_REGION_CMD
    contents = [ command ].pack("C")
    request = GlobalSpaceRequest.new sender, :global_private_region_created,
      request_data
    enq_message command, contents, request
  end


  def enq_delete_private_region_command(sender, private_port)
    command = DELETE_PRIVATE_REGION_CMD
    contents = [ command, private_port ].pack("Cw")
    enq_message command, contents
  end


  def enq_create_region_pair_command(sender, public_port, request_data)
    command = CREATE_REGION_PAIR_CMD
    contents = [ command, public_port ].pack("Cw")
    request = GlobalSpaceRequest.new sender, :global_region_pair_created,
      request_data
    enq_message command, contents, request
  end


  #--------------------------------------------------------------------------

  def enq_message(command, contents, request=nil)
    # For efficiency, this method inlines the relevant parts of enqueue_event.
    @inbox.synchronize do
      # Don't overwrite the request-to-seqnum mapping if it already exists.
      # The only time a request will be re-used is to cancel a previously
      # sent request, and the cancellation request itself can't be cancelled.
      @request_seqnum[request.object_id] ||= @seqnum if request

      message = Message.new @seqnum, command, contents, request
      @seqnum += 1

      @inbox << message
    end

    @control_write.synchronize do
      @control_write.send "M", 0
    end
  end


  def enqueue_event(*message)
    @inbox.synchronize do
      @inbox << message
    end
    
    @control_write.synchronize do
      @control_write.send "M", 0
    end
  end


  def inspect_message(message)
    body = message.map do |element|
      case element
      when String, Numeric, Symbol, TrueClass, FalseClass, NilClass
        element.inspect
      else
        sprintf "#<%s:0x%x>", element.class.name, element.object_id
      end
    end.join(", ")
    "[" + body + "]"
  end


  #--------------------------------------------------------------------------

  def read_data(sock)
    messages = []  # list of payload

    buffer = @read_buffer
    buffer.payload ||= ""

    begin
      # NOTE: To prevent blocking, only do 1 sysread call per read_data() call.
      data = sock.sysread READ_SIZE
      $log.debug "mux read_data from %p: %p", sock, data if $debug_mux_io_bytes

      start = 0
      while start < data.length
	data_left = data.length - start

	desired_length = buffer.length || MESSAGE_LENGTH_SIZE
	fill_amount = desired_length - buffer.payload.length
	usable_amount = [fill_amount, data_left].min

	buffer.payload << data[start, usable_amount]
	start += usable_amount

	if usable_amount == fill_amount
	  if buffer.length
            if $debug_mux_io_bytes
              $log.debug "mux read_data: buffer.length = %d", buffer.length
              $log.debug "mux read_data: buffer.payload = %p", buffer.payload
            end
	    messages << buffer.payload
	    buffer.length = nil
	    buffer.payload = ""
	  else
	    buffer.length = buffer.payload.unpack("N").first
	    buffer.payload = ""
            if $debug_mux_io_bytes
              $log.debug "mux read_data: message length = %d", buffer.length
            end
	    if buffer.length == 0
	      raise EOFError, "mux protocol error: message length == 0"
	    end
	  end
	end
      end

    rescue SocketError, IOError, EOFError, SystemCallError,OpenSSL::SSL::SSLError
      $log.info "mux read_data from %p: %p", sock, $!
      reset_connection
    end

    messages.each do |payload|
      process_demux_message payload
    end
  end


  def write_data(sock)
    buffer = @write_queue.first

    begin
      # NOTE: To prevent blocking, only do 1 syswrite call per write_data().
      n = sock.syswrite buffer.payload
      data_written = buffer.payload.slice! 0, n
      if $debug_mux_io_bytes
        $log.debug "mux write_data to %p: wrote %d bytes, %d left: %p",
          sock, n, buffer.payload.length, data_written
      end

      # syswrite may throw "not opened for writing (IOError)"
    rescue SocketError, IOError, SystemCallError # including Errno::EPIPE
      $log.info "mux write_data to %p: %p", sock, $!
      reset_connection

    else
      if buffer.payload.length == 0
	@write_queue.shift
	@write_set.delete sock if @write_queue.empty?
      end
    end
  end


  def reset_connection
    @read_set.delete @sock
    @write_set.delete @sock
    @sock.close rescue nil
    @sock = nil
    @read_buffer = ReadBuffer.new
    @write_queue = List.new
    open_connection
  end


  public #===================================================================

  # Events from LocalSpace --------------------------------------------------

  # response: [:global_private_region_created, GlobalSpaceMux#self,
  #            request_data]
  def create_private_region(sender, request_data)
    enq_create_private_region_command sender, request_data
  end


  # no response
  def delete_private_region(sender, private_port)
    enq_delete_private_region_command sender, private_port
  end


  # response: [:global_region_pair_created, GlobalSpaceMux#self, request_data]
  def create_region_pair(sender, public_port, request_data)
    enq_create_region_pair_command sender, public_port, request_data
  end


  # Events from LocalSpace: Region proxy events -----------------------------

  def write(recipient, tuple)
    enq_write recipient, tuple
  end

  def read(recipient, request)
    enq_command READ_CMD, recipient, request
  end

  def readp(recipient, request)
    enq_command READP_CMD, recipient, request
  end

  def take(recipient, request)
    enq_command TAKE_CMD, recipient, request
  end

  def takep(recipient, request)
    enq_command TAKEP_CMD, recipient, request
  end

  def read_all(recipient, request, cursor=0)
    enq_command READ_ALL_CMD, recipient, request, cursor
  end

  def take_all(recipient, request, cursor=0)
    enq_command TAKE_ALL_CMD, recipient, request, cursor
  end

  def monitor(recipient, request, cursor=0)
    enq_command MONITOR_CMD, recipient, request, cursor
  end

  def consume(recipient, request, cursor=0)
    enq_command CONSUME_CMD, recipient, request, cursor
  end

  def monitor_stream(recipient, request)
    enq_command MONITOR_STREAM_CMD, recipient, request
  end

  def consume_stream(recipient, request)
    enq_command CONSUME_STREAM_CMD, recipient, request
  end

  def cancel(recipient, request)
    enq_cancel recipient, request
  end

end

end  # module Marinda
