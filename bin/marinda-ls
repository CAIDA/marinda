#!/usr/bin/env ruby

#############################################################################
## The local Marinda server.
##
## There should be just one instance of this server running on each node of
## a given installation of Marinda.  This local server provides access to
## regions in the local tuple space and proxies access to regions in the
## global tuple space.
##
## --------------------------------------------------------------------------
## Copyright (C) 2008, 2009 The Regents of the University of California.
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
## $Id: marinda-ls,v 1.4 2009/03/08 08:00:16 youngh Exp $
#############################################################################

$0 = "marinda-ls"

require 'rubygems'
require 'ostruct'
require 'optparse'
require 'thread'
require 'syslog'
require 'yaml'

require 'marinda/utils'
require 'marinda/config'
require 'marinda/globalmux'
require 'marinda/connection'
require 'marinda/localts'

Thread.abort_on_exception = true

$options = OpenStruct.new
$options.root_dir = "."
$options.use_lock_file = true

opts = OptionParser.new
opts.on("--root", "=DIR",
	"Marinda root dir (default: #{$options.root_dir})") do |v|
  $options.root_dir = v
end

opts.on("-d", "--[no-]detach", TrueClass,
	"run as detached (daemon) process") do |v|
  $options.detach = v
end

opts.on("-v", "--[no-]verbose", TrueClass,  "show detailed progress") do |v|
  $options.verbose = v
end

begin
  ARGV.replace opts.parse(*ARGV)
rescue OptionParser::ParseError
  $stderr.puts "ERROR: " + $!
  $stderr.puts opts
  exit 1
end

#===========================================================================

original_root = $options.root_dir
$options.root_dir = File.expand_path $options.root_dir

unless File.directory? $options.root_dir
  $stderr.puts "ERROR: Marinda root directory '#{$options.root_dir}' " +
    ($options.root_dir == original_root ? "" :
     "(expansion of '#{original_root}') ") +
    "doesn't exist or is not a directory"
  exit 1
end

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

$options.config_path = $options.root_dir + "/local-config.yaml"
$options.lock_file = $options.root_dir + "/localserver.LOCK"

#===========================================================================

syslog_options = Syslog::LOG_PID
syslog_options |= Syslog::LOG_PERROR unless $options.detach
$log = Syslog.open("marinda-ls", syslog_options, Syslog::LOG_LOCAL0)
Syslog.mask = Syslog::LOG_UPTO(Syslog::LOG_DEBUG) if $options.verbose

$lock_handle = nil
$opened_server_socket = nil  # path to the opened server socket

def shutdown_cleanly
  File.unlink $opened_server_socket if $opened_server_socket
  Marinda.release_exclusive_lock $lock_handle if $lock_handle
end

Signal.trap("TERM") do
  $log.info "exiting on SIGTERM"
  shutdown_cleanly()
  exit 2
end

Signal.trap("INT")  do
  $log.info "exiting on SIGINT"
  shutdown_cleanly()
  exit 2
end

Signal.trap("HUP") do
  $log.info "got SIGHUP; will reload config at next opportunity"
  $reload_config = true
end

#===========================================================================

def log_exception(exn)
  msg = exn.class.name + ": " + exn.to_s
  $log.err "ERROR: aborting on exception: %s; backtrace: %s", msg,
    exn.backtrace.join(" <= ")
  msg
end


def log_failure(msg)
  path = $options.root_dir + "/marinda-ls-failed.#{Time.now.to_i}.#{$$}"
  File.open(path, "w") do |file|
    file.puts msg
  end
end


#===========================================================================
# MAIN
#===========================================================================

if $options.use_lock_file
  $lock_handle = Marinda.obtain_exclusive_lock $options.lock_file
  unless $lock_handle
    abort "ERROR: couldn't obtain lock on '#{$options.lock_file}'"
  end
end

config = Marinda::LocalConfig.new $options.config_path
config.export_debugging_flags()
$log.debug "%p", config if $options.verbose

server_sock = UNIXServer.open config.socket
$opened_server_socket = config.socket

if $options.detach
  $stderr.puts "starting marinda-ls in background\n"
  Marinda::daemonize()
  $log.info "started marinda-ls in background"
end

begin
  mux = nil
  unless config.localspace_only
    if config.use_ssl
      connection = Marinda::ClientSSLConnection.new config.demux_addr,
      config.demux_port, config.cert, config.key, config.ca_file, config.ca_path
    else
      connection = Marinda::InsecureClientConnection.new config.demux_addr,
        config.demux_port
    end
    mux = Marinda::GlobalSpaceMux.new config.node_id, connection
  end

  local_space = Marinda::LocalSpace.new config.node_id, mux

  loop do
    $log.info "waiting for clients on %s", config.socket

    if $reload_config
      $reload_config = false
      $log.info "reloading config file on SIGHUP."
      old_config = config
      begin
        # XXX Changing the connection and other settings of a running local
        #     space isn't implemented right now.
        config = Marinda::LocalConfig.new $options.config_path
        config.export_debugging_flags()
        $log.debug "%p", config if $options.verbose
      rescue # LocalConfig::MalformedConfigException & YAML exceptions
        config = old_config
        log_exception $!
      end
    end

    sock = nil
    begin
      sock = server_sock.accept
    rescue
      log_exception $!
    end

    local_space.add_client sock if sock
  end

rescue
  short_msg = $!.class.name + ": " + $!.to_s
  msg = sprintf "marinda-ls: exiting on uncaught exception " +
    "at top-level: %p; backtrace: %s", $!, $!.backtrace.join(" <= ")
  $log.err "%s", msg
  log_failure msg rescue nil
  exit 1
end

if $options.use_lock_file
  Marinda.release_exclusive_lock $lock_handle
end
